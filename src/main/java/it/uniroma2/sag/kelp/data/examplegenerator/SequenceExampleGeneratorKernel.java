/*
 * Copyright 2016 Simone Filice and Giuseppe Castellucci and Danilo Croce and Roberto Basili
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package it.uniroma2.sag.kelp.data.examplegenerator;

import java.io.IOException;

import com.fasterxml.jackson.annotation.JsonTypeName;

import it.uniroma2.sag.kelp.data.example.Example;
import it.uniroma2.sag.kelp.data.example.SequenceExample;
import it.uniroma2.sag.kelp.data.example.SequencePath;
import it.uniroma2.sag.kelp.data.representation.Representation;
import it.uniroma2.sag.kelp.data.representation.vector.SparseVector;

/**
 * A <code>SequenceExampleGeneratorKernelBasedAlg</code> allows to
 * <b>implicitly</b> enrich a targeted <code>Example</code> (reflecting an item
 * in a <code>SequenceExample</code>) with information derived from the <Label>s
 * assigned to the previous <code>n</code> examples.
 * 
 * <br>
 * 
 * 
 * Given a representation used to represent an example, this
 * <code>SequenceExampleGenerator</code> generates a new example containing only
 * feature reflecting the classes assigned to the previous examples in the
 * sequence.
 * 
 * <br>
 * 
 * This class should be used when the kernel based learning algorithm is used.
 * While a kernel function operates on the original representation, an
 * additional kernel function should operate on the additional representation
 * generated by this example generator.
 * 
 * @author Danilo Croce
 *
 */
@JsonTypeName("se_gen_kb")
public class SequenceExampleGeneratorKernel implements SequenceExampleGenerator {

	private String transitionRepresentationName;

	private int transitionsOrder;

	public SequenceExampleGeneratorKernel() {
	}

	public SequenceExampleGeneratorKernel(int transitionsOrder, String transitionRepresentationName) {
		this.transitionRepresentationName = transitionRepresentationName;
		this.transitionsOrder = transitionsOrder;
	}

	public Example generateExampleWithHistory(SequenceExample sequenceExample, SequencePath p, int elementId) {

		Example innerExample = sequenceExample.getExample(elementId);

		Example enrichedObservedExample = innerExample.duplicate();

		String transitionString = p.getHistoryBefore(elementId, transitionsOrder);

		Representation enrichedObservationRepresentation = generateManipulatedRepresentation(transitionString);
		/*
		 * Enrich the observed representation with the previous transition
		 */
		enrichedObservedExample.addRepresentation(transitionRepresentationName, enrichedObservationRepresentation);

		return enrichedObservedExample;
	}

	private Representation generateManipulatedRepresentation(String transitionString) {
		try {
			SparseVector newRepresentation = new SparseVector();
			if (transitionString.trim().length() > 0)
				newRepresentation.setDataFromText(transitionString + ":1.0");
			return newRepresentation;
		} catch (IOException e) {
			e.printStackTrace();
			return null;
		}

	}

	@Override
	public SequenceExample generateSequenceExampleEnrichedWithHistory(SequenceExample sequenceExample) {
		SequenceExample res = (SequenceExample) (sequenceExample.duplicate());

		for (int elementId = 0; elementId < res.getLenght(); elementId++) {

			Example e = res.getExample(elementId);

			String transitionString = new String();
			for (int j = elementId - transitionsOrder; j < elementId; j++) {
				if (j < 0) {
					transitionString += SequenceExample.SEQDELIM + j + "init";
				} else {
					Example ej = sequenceExample.getExample(j);
					transitionString += SequenceExample.SEQDELIM + ej.getClassificationLabels().iterator().next();
				}
			}
			Representation newRepresentation = generateManipulatedRepresentation(transitionString);
			e.getRepresentations().put(transitionRepresentationName, newRepresentation);
		}

		return res;
	}

	public String getTransitionRepresentationName() {
		return transitionRepresentationName;
	}

	@Override
	public int getTransitionsOrder() {
		return transitionsOrder;
	}

	public void setTransitionRepresentationName(String transitionRepresentationName) {
		this.transitionRepresentationName = transitionRepresentationName;
	}

	public void setTransitionsOrder(int transitionsOrder) {
		this.transitionsOrder = transitionsOrder;
	}

}
